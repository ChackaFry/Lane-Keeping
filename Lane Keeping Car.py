import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import solve_ivp


class PIDController:
    """
    PIDController class can be used give PID controls to one input of a given system.

    Methods
    -------
    __init__(self, kp, ki, kd, ts)
        Constructor the the PIDController class.
    control(self, recorded_value, set_point=0)
        Outputs the PID controlled input for the system, based 1 recorded value, and set-point

    Attributes
    ----------
    __kp: float
        P constant
    __ki: float
        I constant
    __kd: float
        D constant
    __ts: float
        sampling time
    __err_previous = None : float
        previous value of error recorded
    __error_sum = 0 : float
        sum of all the errors
    """

    def __init__(self, kp, ki, kd, ts):
        """
        Constructor the the PIDController class.
        :param kp: float representing P constant
        :param ki: float representing I constant
        :param kd: float representing D constant
        :param ts: float representing the sampling time
        """
        self.__kp = kp  # Controller's P constant
        self.__kd = kd / ts  # Controller's D constant
        self.__ki = ki * ts  # Controller's I constant
        self.__ts = ts  # Controller's sampling time
        self.__err_previous = None  # Controller's previous error (there is no error before t = 0s)
        self.__error_sum = 0  # Controller's cumulative error

    def control(self, recorded_value, set_point=0.0):
        """
        Outputs the PID controlled input for the system, based 1 recorded value, and set-point
        :param recorded_value: float representing the recorded value
        :param set_point: float representing the set-point of the system
        :return: float representing the output generated by the controller
        """
        error = set_point - recorded_value  # Calculating the current error
        # print(error)

        output = self.__kp * error  # P Component
        output += self.__ki * (self.__error_sum + error)  # I Component

        if self.__err_previous is not None:
            output += self.__kd * (error - self.__err_previous)  # D Component

        self.__error_sum += error  # Cumulative Error
        self.__err_previous = error  # Previous Error

        return output


class Car:
    """
    This class represents a Car.

    Methods
    -------
    __init__(self, length=0.9, velocity=1.0, x_pos_init=0.0, y_pos_init=0.0, rotational_pos_init=0.0)
        Constructor the the Car class.
    move(self, steering_angle, dt)
        Simulates the movement of the Car, at the given steering_angle, for the given time dt
    static car_dynamics(time, z, velocity, length, steering_angle, disturbance)
        This function defines the dynamical equations that govern the car.
    state(self)
        Returns the current position of the Car

    Attributes
    ----------
    __length: float
        length of the Car
    __velocity: float
        velocity of the Car
    __x_pos: float
        x position of the car
    __y_pos: float
        y position of the car
    __rotational_pos = None : float
        orientation/rotation of the Car in Rad
    """

    def __init__(self, length, velocity, x_pos_init, y_pos_init, rotational_pos_init):
        """
        Constructor the the Car class.
        :param length: float representing length of the Car
        :param velocity: float representing velocity of the Car
        :param x_pos_init: float representing initial x-position of the Car
        :param y_pos_init: float representing initial y-position of the Car
        :param rotational_pos_init: float representing initial orientation/rotation of the Car in Rad
        """
        self.__length = length
        self.__velocity = velocity
        self.__x_pos = x_pos_init
        self.__y_pos = y_pos_init
        self.__rotational_pos = rotational_pos_init

    def move(self, steering_angle, disturbance, dt):
        """
        Simulates the movement of the Car, at the given steering_angle, for the given time dt
        :param steering_angle: float representing angle of the steering wheel in Rad
        :param disturbance: float representing the disturbance in the system
        :param dt: float representing how long the simulation will be run for,
                    from the Car's current x_pos, y_pos, and rotational_pos
        :return: list of list of float representing the state of the car at certain times.
                    [[x_pos, y_pos, rotational_pos]...]
        """
        init_values = (self.__x_pos, self.__y_pos, self.__rotational_pos,)
        state_values = solve_ivp(lambda time, z:
                                 self.car_dynamics(time, z,
                                                   self.__velocity, self.__length, steering_angle, disturbance),
                                 [0, dt],
                                 init_values,
                                 t_eval=np.linspace(0, dt, 51))
        final_state = state_values.y.T[-1]
        self.__x_pos = final_state[0]
        self.__y_pos = final_state[1]
        self.__rotational_pos = final_state[2]
        return state_values

    @staticmethod
    def car_dynamics(time, z, velocity, length, steering_angle, disturbance=0.0):
        """
        This function defines the dynamical equations that govern the car.
        :param time: float representing the time variable
        :param z: list of length 3.
                    represents the state variable.
                                    z[0] float representing x,
                                    z[1] float representing y,
                                    z[2] float representing theta
        :param velocity: float representing the velocity with which the car is moving
        :param length: float representing the axle to axle length
        :param steering_angle: float representing the angle of the steering wheel
        :param disturbance: optional float representing the disturbance in the system
        :return: [x_dot, y_dot, theta_dot]
        """
        x_dot = velocity * np.cos(z[2])
        y_dot = velocity * np.sin(z[2])
        theta_dot = (velocity / length) * np.tan(steering_angle + disturbance)
        return [x_dot, y_dot, theta_dot]

    def state(self):
        """
        Returns the current position of the Car
        :return: list of length 3.
                    [0] : float representing __x_pos
                    [1] : float representing __y_pos
                    [2] : float representing __rotational_pos
        """
        return self.__x_pos, self.__y_pos, self.__rotational_pos


def simulator(sim_time, new_car_init_values,
              kp_val, kd_val, ki_val, ts_val,
              set_point=0, steering_angle=0, disturbance=0):
    """
    This function does all of the simulations.
    :param sim_time: float representing the amount of time the simulation will be run for.
    :param new_car_init_values: list of length 5, containing all the value needed to create
                                    a new Car object, the values need to appear in the correct order
                                    [length, velocity, x_pos, y_pos, rotational_pos]
    :param kp_val: float or list representing kp value(s) of PIDController
    :param kd_val: float or list representing kd value(s) of PIDController
    :param ki_val: float or list representing ki value(s) of PIDController
    :param ts_val: float or list representing ts value(s) of PIDController
    :param set_point: optional float representing the set_point for the simulation
                        default value is 0.0
    :param steering_angle: optional float representing the steering_angle for the simulation
                            if this value is set, the simulator will assume Open Loop Control,
                            regardless of the other values present.
    :param disturbance: optional float representing the disturbance that acts on the system.
                        default value is 0.0
    :return: list of length 2, representing a list of state and steering angle of the car at various times.
                The list of steering angle is only produced, when the simulator is run in Closed Loop Control.
                Both these list are multi-dimensional arrays.
                state[m], steering[m] are the values of state at the mth simulation.
                state[m][n], steering[m][n] these values at a certain time.
                state[m][n] is a list of length 3. [0] is x_pos, [1] is y_pos [2] is rotaional_pos
                steering[m][n] is a list of length 1. [0] is the steering_angle
    """
    # Values needed to create a new car
    length = new_car_init_values[0]
    velocity = new_car_init_values[1]
    x_pos = new_car_init_values[2]
    y_pos = new_car_init_values[3]
    theta_pos = new_car_init_values[4]

    # For Open Loop Control
    if steering_angle != 0:
        new_car = Car(length, velocity, x_pos, y_pos, theta_pos)
        simulations = int(sim_time / ts_val)
        state_recorder = np.array(new_car.state())
        for i in range(simulations):
            state_values = new_car.move(steering_angle, disturbance, ts_val)
            state_recorder = np.vstack((state_recorder, state_values.y.T))
        return state_recorder

    # For Closed Loop Control

    # PID Constants and Sampling Time
    # If the value is a float/ int, it is converted to a list
    # Everything needs to be a list for the iterating code to work
    kp = kp_val if type(kp_val) == list else [kp_val]
    kd = kd_val if type(kd_val) == list else [kd_val]
    ki = ki_val if type(ki_val) == list else [ki_val]
    ts = ts_val if type(ts_val) == list else [ts_val]

    # car0 created just to initialise the *_recorder variables
    car0 = Car(length, velocity, x_pos, y_pos, theta_pos)

    # These initialised values need to be removed
    state_recorder = [np.array(car0.state()), ]
    steering_recorder = [np.array(0), ]
    sim_count = 0  # this is used to keep track of which simulation the data came from

    # Iterating through all given values in the kp, kd, ki, ts lists
    for p in kp:
        for d in kd:
            for i in ki:
                for t in ts:
                    simulations = int(sim_time / t)

                    controller = PIDController(p, i, d, t)
                    new_car = Car(length, velocity, x_pos, y_pos, theta_pos)

                    state_recorder.append(np.array(new_car.state()))

                    # This initialised value needs to be removed for each simulation
                    steering_recorder.append(np.array(0))
                    sim_count += 1

                    # Running the simulation
                    for number in range(simulations):
                        # These values need to be recorded
                        pid_steering = controller.control(new_car.state()[1], set_point)
                        state_values = new_car.move(pid_steering, disturbance, t)

                        # Recording the values, by adding them to the list
                        state_recorder[sim_count] = np.vstack((state_recorder[sim_count],
                                                               state_values.y.T))
                        steering_recorder[sim_count] = np.append(steering_recorder[sim_count],
                                                                 pid_steering)
    # The initialised values are removed
    state_recorder.pop(0)
    steering_recorder.pop(0)

    # steering_recorder falsely starts at 0
    # In reality it starts at pid_steering
    steering_recorder = np.array(steering_recorder).T  # Transpose the array
    steering_recorder = np.delete(steering_recorder, 0, 0)  # Delete the values at arr[0]
    steering_recorder = steering_recorder.T  # un-Transpose the array
    return state_recorder, steering_recorder


def plotter(x_label, y_label, title, x_coordinates, y_coordinates, line_type="-", label=""):
    """
    This function is used to plot the graphs.
    :param x_label: str representing the x axis label
    :param y_label: str representing the y axis label
    :param title: str representing the title of the graph
    :param x_coordinates: list of float representing x coordinates for the graph
    :param y_coordinates: list of float representing y coordinates for the graph
    :param line_type: optional str representing the linetype value of pyplot.plot()
                        default value is "-"
    :param label: optional str representing the label value of a certain line
                    default value is ""
    """
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.grid(True, "both", "both")
    plt.title(title)
    plt.plot(x_coordinates, y_coordinates, line_type, label=label)


def save_plot(names):
    """
    This function is responsible for showing the graph and saving it
    :param names: list of string representing the names of all the graphs.
    """
    plt.savefig(names[0] + ".eps", format="eps")
    plt.show()
    names.remove(names[0])


def question1(names):
    t_final = 2
    sampling_time = 0.01  # The time each simulation will be sampled for
    simulations = int(t_final / sampling_time)

    init_car = [2.3, 5, 0, 0.3, np.deg2rad(5)]
    steering = np.deg2rad(-2)

    black_box = simulator(t_final, init_car, 0, 0, 0, sampling_time, steering_angle=steering)

    start_point = black_box[0][0], black_box[0][1]  # Starting point of the car
    end_point = black_box[-1][0], black_box[-1][1]  # Finish point of the car

    # Plotting details for Question 1.1
    points = simulations * 51 + 1  # Used for plotting points
    times = np.linspace(0, t_final, points).T  # Times against which points are plotted
    x_label = "Time - t (s)"

    plotter(x_label, "Position - x (m)", f"Change of Position x in {t_final:.1f}s",
            times, black_box.T[0, :], 'b--')
    save_plot(names)

    plotter(x_label, "Position - y (m)", f"Change of Position y in {t_final:.1f}s",
            times, black_box.T[1, :], 'r--')
    save_plot(names)

    black_box.T[2, :] = np.rad2deg(black_box.T[2, :])  # Converting Radians to Degrees
    plotter(x_label, "Rotation - θ (°)", f"Change of Rotation θ in {t_final:.1f}s",
            times, black_box.T[2, :], 'g--')
    save_plot(names)

    # Plotting details for Question 1.2
    plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
            black_box.T[0, :], black_box.T[1, :], 'm--')
    plt.annotate("Start", start_point, ha="center", va="bottom")
    plt.scatter(start_point[0], start_point[1])
    plt.annotate("End", end_point, ha="center", va="bottom")
    plt.scatter(end_point[0], end_point[1])
    save_plot(names)


def question2_1(name):
    t_final = 50.0
    sampling_rate = 40
    sampling_time = 1 / sampling_rate  # The time each simulation will be sampled for

    kp = [0.005, 0.05, 0.15, 0.5]
    disturbance = np.deg2rad(1)  # Disturbance of 1deg in anticlockwise direction
    init_car = (2.3, 5, 0, 0.3, np.deg2rad(5))

    black_box_sims = simulator(t_final, init_car, kp, 0, 0, sampling_time, disturbance=disturbance)[0]

    for value in range(0, len(black_box_sims)):
        black_box = black_box_sims[value]
        plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
                black_box.T[0, :], black_box.T[1, :], label=f"{kp[value]:.3f}")
    plt.legend(title="Values of Kp at", loc='upper right')
    save_plot(name)


def question2_2(name):
    t_final = 50.0
    sampling_rate = 40
    sampling_time = 1 / sampling_rate  # The time each simulation will be sampled for

    kp = 0.15
    kd = [0.05, 0.1, 0.20, 0.5]
    disturbance = np.deg2rad(1)  # Disturbance of 1deg in anticlockwise direction
    init_car = [2.3, 5, 0, 0.3, np.deg2rad(5)]

    black_box_sims = simulator(t_final, init_car, kp, kd, 0, sampling_time, disturbance=disturbance)[0]

    for value in range(0, len(black_box_sims)):
        black_box = black_box_sims[value]
        plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
                black_box.T[0, :], black_box.T[1, :], label=f"{kd[value]:.2f}")
    plt.legend(title="Values of Kd at", loc='upper right')
    save_plot(name)


def question2_3_additional(name):
    t_final = 50.0
    sampling_rate = 40
    sampling_time = 1 / sampling_rate  # The time each simulation will be sampled for

    kp = 0.15
    kd = 0.2
    ki = [0.01, 0.02, 0.05, 0.1]
    disturbance = np.deg2rad(1)  # Disturbance of 1deg in anticlockwise direction
    init_car = [2.3, 5, 0, 0.3, np.deg2rad(5)]

    black_box_sims = simulator(t_final, init_car, kp, kd, ki, sampling_time, disturbance=disturbance)[0]

    for value in range(0, len(black_box_sims)):
        black_box = black_box_sims[value]
        plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
                black_box.T[0, :], black_box.T[1, :], label=f"{ki[value]:.2f}")
    plt.legend(title="Values of Ki at", loc='upper right')
    save_plot(name)


def question2_3(names):
    t_final = 50.0
    sampling_rate = 40
    sampling_time = 1 / sampling_rate  # The time each simulation will be sampled for
    simulations = int(t_final / sampling_time)

    kp = 0.15
    kd = 0.2
    ki = 0.02
    disturbance = np.deg2rad(1)  # Disturbance of 1deg in anticlockwise direction
    init_car = [2.3, 5, 0, 0.3, np.deg2rad(5)]

    black_box_sims = simulator(t_final, init_car, kp, kd, ki, sampling_time, disturbance=disturbance)
    state_records = black_box_sims[0][0]
    steering_records = black_box_sims[1][0]

    points = simulations  # Used for plotting points
    times = np.linspace(0, t_final, points)  # Times against which points are plotted

    steering_angle = np.rad2deg(np.array(steering_records))

    # Q2.3.i
    plotter("Time - t (s)", "Steering Angle - u (°)", f"Change in Steering Angle u in {t_final:.1f}s",
            times, steering_angle)
    save_plot(names)

    # Q2.3.ii
    plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
            state_records.T[0, :], state_records.T[1, :])
    save_plot(names)


def question2_4(name):
    t_final = 25.0  # Amount of time the simulated
    sampling_time = [0.01, 0.1, 0.5, 0.6]

    kp = 0.15
    kd = 0.2
    ki = 0.02
    disturbance = np.deg2rad(1)  # Disturbance of 1deg in anticlockwise direction
    init_car = [2.3, 5, 0, 0.3, np.deg2rad(5)]

    black_box_sims = simulator(t_final, init_car, kp, kd, ki, sampling_time, disturbance=disturbance)[0]

    for value in range(0, len(black_box_sims)):
        black_box = black_box_sims[value]
        plotter("Position - x (m)", "Position - y (m)", f"Trajectory of the Car in {t_final:.1f}s",
                black_box.T[0, :], black_box.T[1, :], label=f"{sampling_time[value]:.2f}")
    plt.legend(title="Values of Ts at", loc='upper right')
    save_plot(name)


def question3():
    t_final = 50
    sampling_time = 0.1

    car1 = [2.3, 5, 0, 0, np.deg2rad(5)], np.deg2rad(-2)
    car2 = [2.5, 5, 0, 0, np.deg2rad(20)], np.deg2rad(-10)
    car3 = [5, 10, 0, 0, np.deg2rad(40)], np.deg2rad(-30)
    car4 = [5, 5, 0, 0, np.deg2rad(40)], np.deg2rad(-60)
    car5 = [10, 10, 0, 0, np.deg2rad(40)], np.deg2rad(-60)
    car_arr = [car1, car2, car3, car4, car5]

    print("Question 3 Simulated Values")

    for value in range(0, len(car_arr)):
        car = car_arr[value]
        black_box = simulator(t_final, car[0], 0, 0, 0, sampling_time, steering_angle=car[1])

        theta_calc = (car[0][1] / car[0][0]) * np.tan(car[1]) * t_final + car[0][4]
        x_calc = (car[0][0] / np.tan(car[1])) * (np.sin(theta_calc) - np.sin(car[0][4])) + car[0][2]
        y_calc = (car[0][0] / np.tan(car[1])) * (np.cos(car[0][4]) - np.cos(theta_calc)) + car[0][3]

        # Fixing angles to the range, (-180deg, 180deg]
        theta = np.rad2deg(black_box[-1][2]) % 360
        theta = theta if theta <= 180 else theta - 360

        # Fixing angles to the range, (-180deg, 180deg]
        theta_calc = np.rad2deg(theta_calc) % 360
        theta_calc = theta_calc if theta_calc <= 180 else theta_calc - 360

        # Answers inserted into LaTex PDF
        print(f"{car[0][0]:.1f} & {car[0][1]:.1f} & "
              f"{np.rad2deg(car[1]):.1f} & {np.rad2deg(car[0][4]):.1f} & "  # Variables
              f"{black_box[-1][0]:.3f} & {black_box[-1][1]:.3f} & {theta:.3f} & "  # solve_ivp values
              f"{x_calc:.3f} & {y_calc:.3f} & {theta_calc:.3f} \\cr")  # calculated values


question1(['q1_x_t', 'q1_y_t', 'q1_theta_t', 'q1Trajectory'])
question2_1(['q2_1_trajectory'])
question2_2(['q2_2_trajectory'])
question2_3(['q2_3i_u_t', 'q2_3ii_trajectory'])
question2_3_additional(['q2_3ii_trajectory2'])
question2_4(['q2_4_trajectory'])
question3()
print("All Simulations Complete")
